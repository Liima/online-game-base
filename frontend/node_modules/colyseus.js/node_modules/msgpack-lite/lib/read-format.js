// read-format.js

exports.format = {
  map: map,
  array: array,
  str: str,
  bin: bin,
  ext: ext,
  uint8: uint8,
  uint16: uint16,
  uint32: read(4, Buffer.prototype.readUInt32BE),
  uint64: read(8, readUInt64BE),
  int8: read(1, Buffer.prototype.readInt8),
  int16: read(2, Buffer.prototype.readInt16BE),
  int32: read(4, Buffer.prototype.readInt32BE),
  int64: read(8, readInt64BE),
  float32: read(4, Buffer.prototype.readFloatBE),
  float64: read(8, Buffer.prototype.readDoubleBE)
};

var BufferLite = require("./buffer-lite");
var decode = require("./read-core").decode;
var codec = require("./ext-preset").preset;
var BUFFER_SHORTAGE = require("./common").BUFFER_SHORTAGE;

var IS_BUFFER_SHIM = ("TYPED_ARRAY_SUPPORT" in Buffer);
var NO_ASSERT = true;

function map(decoder, len) {
  var value = {};
  var i;
  var k = new Array(len);
  var v = new Array(len);
  for (i = 0; i < len; i++) {
    k[i] = decode(decoder);
    v[i] = decode(decoder);
  }
  for (i = 0; i < len; i++) {
    value[k[i]] = v[i];
  }
  return value;
}

function array(decoder, len) {
  var value = new Array(len);
  for (var i = 0; i < len; i++) {
    value[i] = decode(decoder);
  }
  return value;
}

function str(decoder, len) {
  var start = decoder.offset;
  var end = decoder.offset = start + len;
  if (end > decoder.buffer.length) throw BUFFER_SHORTAGE;
  if (IS_BUFFER_SHIM) {
    // slower (compat)
    return BufferLite.readString.call(decoder.buffer, start, end);
  } else {
    // 2x faster
    return decoder.buffer.toString("utf-8", start, end);
  }
}

function bin(decoder, len) {
  var start = decoder.offset;
  var end = decoder.offset = start + len;
  if (end > decoder.buffer.length) throw BUFFER_SHORTAGE;
  return decoder.buffer.slice(start, end);
}

function ext(decoder, len) {
  var start = decoder.offset;
  var end = decoder.offset = start + len + 1;
  if (end > decoder.buffer.length) throw BUFFER_SHORTAGE;
  var type = decoder.buffer[start];
  var unpack = codec.getExtUnpacker(type);
  if (!unpack) throw new Error("Invalid ext type: " + (type ? ("0x" + type.toString(16)) : type));
  var buf = decoder.buffer.slice(start + 1, end);
  return unpack(buf);
}

function uint8(decoder) {
  var buffer = decoder.buffer;
  if (decoder.offset >= buffer.length) throw BUFFER_SHORTAGE;
  return buffer[decoder.offset++];
}

function uint16(decoder) {
  var buffer = decoder.buffer;
  if (decoder.offset + 2 > buffer.length) throw BUFFER_SHORTAGE;
  return (buffer[decoder.offset++] << 8) | buffer[decoder.offset++];
}

function read(len, method) {
  return function(decoder) {
    var start = decoder.offset;
    var end = decoder.offset = start + len;
    if (end > decoder.buffer.length) throw BUFFER_SHORTAGE;
    return method.call(decoder.buffer, start, NO_ASSERT);
  };
}

function readUInt64BE(start, noAssert) {
  var upper = this.readUInt32BE(start, noAssert);
  var lower = this.readUInt32BE(start + 4, noAssert);
  return upper ? (upper * 4294967296 + lower) : lower;
}

function readInt64BE(start, noAssert) {
  var upper = this.readInt32BE(start, noAssert);
  var lower = this.readUInt32BE(start + 4, noAssert);
  return upper ? (upper * 4294967296 + lower) : lower;
}
